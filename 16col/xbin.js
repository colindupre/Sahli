// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.ImageTextModeXBin = (function(_super) {
    var ATTRIBUTE_COMPRESSION, CHARACTER_COMPRESSION, COMPRESSED, COMPRESSION_COUNTER, COMPRESSION_TYPE, FIVETWELVE_CHARS, FONT, FULL_COMPRESSION, NON_BLINK, NO_COMPRESSION, PALETTE;

    __extends(ImageTextModeXBin, _super);

    PALETTE = 1;

    FONT = 2;

    COMPRESSED = 4;

    NON_BLINK = 8;

    FIVETWELVE_CHARS = 16;

    NO_COMPRESSION = 0;

    CHARACTER_COMPRESSION = 64;

    ATTRIBUTE_COMPRESSION = 128;

    FULL_COMPRESSION = 192;

    COMPRESSION_TYPE = 192;

    COMPRESSION_COUNTER = 63;

    function ImageTextModeXBin(options) {
      var k, v;
      ImageTextModeXBin.__super__.constructor.apply(this, arguments);
      this.header = {
        width: 0,
        height: 0,
        fontisze: 0,
        flags: 0
      };
      for (k in options) {
        if (!__hasProp.call(options, k)) continue;
        v = options[k];
        this[k] = v;
      }
    }

    ImageTextModeXBin.prototype.parse = function(content) {
      var fontlength, headerData, offset;
      this.screen = [];
      headerData = content.substr(0, 11);
      if (headerData.length !== 11 || !headerData.match('^XBIN\x1a')) {
        throw new Error('File is not an XBin');
      }
      this.header.width = this.unpackShort(headerData.substr(5, 2));
      this.header.height = this.unpackShort(headerData.substr(7, 2));
      this.header.fontsize = this.getByteAt(headerData.substr(9, 1));
      this.header.flags = this.getByteAt(headerData.substr(10, 1));
      offset = 11;
      if (this.header.flags & PALETTE) {
        this.parsePaletteData(content.substr(offset, 48));
        offset += 48;
      }
      if (this.header.flags & FONT) {
        fontlength = this.header.fontsize;
        if (this.header.flags & FIVETWELVE_CHARS) {
          fontlength *= 512;
        } else {
          fontlength *= 256;
        }
        this.parseFontData(content.substr(offset, fontlength), this.header.fontsize);
        offset += fontlength;
      }
      if (this.header.flags & COMPRESSED) {
        return this._parse_compressed(content.substr(offset));
      } else {
        return this._parse_uncompressed(content.substr(offset));
      }
    };

    ImageTextModeXBin.prototype._parse_compressed = function(data) {
      var attr, ch, counter, info, type, x, y, _results;
      x = 0;
      y = 0;
      this.screen[y] = [];
      data = data.split('');
      _results = [];
      while (info = data.shift()) {
        info = this.getByteAt(info, 0);
        if (info === 26) {
          break;
        }
        type = info & COMPRESSION_TYPE;
        counter = (info & COMPRESSION_COUNTER) + 1;
        ch = null;
        attr = null;
        _results.push((function() {
          var _results1;
          _results1 = [];
          while (counter-- > 0) {
            switch (type) {
              case NO_COMPRESSION:
                ch = data.shift();
                attr = data.shift();
                break;
              case CHARACTER_COMPRESSION:
                if (ch == null) {
                  ch = data.shift();
                }
                attr = data.shift();
                break;
              case ATTRIBUTE_COMPRESSION:
                if (attr == null) {
                  attr = data.shift();
                }
                ch = data.shift();
                break;
              default:
                if (ch == null) {
                  ch = data.shift();
                }
                if (attr == null) {
                  attr = data.shift();
                }
            }
            this.screen[y][x] = {
              ch: ch,
              attr: this.getByteAt(attr, 0)
            };
            x++;
            if (x === this.header.width) {
              x = 0;
              y++;
              if (y === this.header.height) {
                break;
              }
              if (this.screen[y] == null) {
                _results1.push(this.screen[y] = []);
              } else {
                _results1.push(void 0);
              }
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    ImageTextModeXBin.prototype._parse_uncompressed = function(data) {
      var attr, ch, i, x, y, _i, _ref, _results;
      x = 0;
      y = 0;
      this.screen[y] = [];
      _results = [];
      for (i = _i = 0, _ref = data.length - 2; _i <= _ref; i = _i += 2) {
        ch = data.substr(i, 1);
        if (ch === "\x1a") {
          break;
        }
        attr = this.getByteAt(data, i + 1);
        this.screen[y][x] = {
          'ch': ch,
          'attr': attr
        };
        x++;
        if (x === this.header.width) {
          x = 0;
          y++;
          if (y === this.header.height) {
            break;
          }
          if (this.screen[y] == null) {
            _results.push(this.screen[y] = []);
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    ImageTextModeXBin.prototype.getWidth = function() {
      return this.header.width;
    };

    ImageTextModeXBin.prototype.getHeight = function() {
      return this.header.height;
    };

    return ImageTextModeXBin;

  })(this.ImageTextMode);

}).call(this);
